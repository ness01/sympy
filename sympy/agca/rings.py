"""Classes representing various commutative rings"""

from sympy.core import Basic

from sympy.polys import CoercionFailed, ExactQuotientFailed
from sympy.polys.polyclasses import DMF

class RingElement(Basic):
    """
    Represents a ring element.

    This class stores both the containing ring, and data representing an
    element. It is completely agnostic to operations, just transfers all
    operations to the ring.

    It should never be instantiated by the user.
    """

    # This should give us precedence over sympy.core
    _op_priority = 20.0

    @property
    def ring(self):
        return self.args[0]

    @property
    def data(self):
        return self.args[1]

    def __add__(f, g):
        return f.__class__(f.ring, f.ring.element_add(f.data, f.ring.convert(g).data))

    def __radd__(f, g):
        return f.__class__(f.ring, f.ring.element_add(f.ring.convert(g).data, f))

    def __sub__(f, g):
        return f.__class__(f.ring, f.ring.element_sub(f.data, f.ring.convert(g).data))

    def __rsub__(f, g):
        return f.__class__(f.ring, f.ring.element_sub(f.ring.convert(g).data, f.data))

    def __mul__(f, g):
        return f.__class__(f.ring, f.ring.element_mul(f.data, f.ring.convert(g).data))

    def __rmul__(f, g):
        return f.__class__(f.ring, f.ring.element_mul(f.ring.convert(g).data, f.data))

    def __div__(f, g):
        return f.__class__(f.ring, f.ring.element_div(f.data, f.ring.convert(g).data))

    def __rdiv__(f, g):
        return f.__class__(f.ring, f.ring.element_div(f.ring.convert(g).data, f.data))

    def __neg__(f):
        return f.__class__(f.ring, f.ring.element_neg(f.data))

    def __eq__(f, g):
        return f.ring.element_equal(f.data, f.ring.convert(g).data)

    def __neq__(f, g):
        return not self.__eq__(f, g)

    # TODO more operations

    @property
    def is_unit(self):
        """Determine if ``self`` has a multiplicative inverse."""
        return self.ring.element_is_unit(self)

    def inverse(self):
        """Determine the inverse of self, if it exists."""
        return self.ring.element_inverse(self)

class Ring(Basic):
    """Base class for (commutative) rings. Should not be instantiated."""

    @property
    def is_zero_ring(self):
        raise NotImplementedError

    @property
    def is_integral_domain(self):
        raise NotImplementedError

    @property
    def is_field(self):
        raise NotImplementedError

    @property
    def name(self):
        """A short name, for printing."""
        return None

    def _ideal(self, *gens, **opts):
        raise NotImplementedError

    def ideal(self, *gens, **opts):
        """Returns the ideal generated by ``gens``."""
        return self._ideal(*[convert(g) for g in gens], **opts)

    def free_module(self, rank, **options):
        """Returns a free module of rank ``rank`` over ``self``."""
        raise NotImplementedError

    def _polynomial_extension(self, *gens, **opts):
        raise NotImplementedError

    def polynomial_extension(self, *gens, **opts):
        """Generate a polynomial extension of this ring."""
        return _polynomial_extension(self, *[convert(g) for g in gens], **opts)

    def quotient_ring(self, ideal):
        raise NotImplementedError

    def __getitem__(self, *gens, **opts):
        return self.polynomial_extension(self, *gens, **opts)

    def convert(self, expr):
        raise CoercionFailed

    def contains(self, expr):
        try:
            self.convert(expr)
            return True
        except (CoercionFailed, ExactQuotientFailed):
            return False

    def __contains__(self, expr):
        return self.contains(expr)

    # Operations on elements TODO more
    def element_mul(self, a, b):
        return a * b

    def element_add(self, a, b):
        return a + b

    def element_sub(self, a, b):
        return a - b

    def element_div(self, a, b):
        return a / b

    def element_neg(self, a):
        return -a

    def element_equal(self, a, b):
        return a == b

    def element_is_unit(self, a):
        try:
            self.element_inverse(a)
            return True
        except ExactQuotientFailed:
            return False

    def element_inverse(self, a):
        return self.convert(1) / a

class PolynomialRingElement(RingElement):
    """
    Represents elements of generalized polynomial rings.

    Should not be instantiated by the user.
    """

    def numer_DMP(e):
        return e.data.numer()

    def denom_DMP(e):
        return e.data.denom()

    def numer_terms(e):
        return e.numer_DMP().terms(order=e.ring.monomial_order)

    def denom_terms(e):
        return e.denom_DMP().terms(order=e.ring.monomial_order)

    def numer_LT(e):
        return e.numer_terms()[0]

    def numer_LM(e):
        return e.numer_terms()[0][0]

    def denom_LT(e):
        return e.denom_terms()[0]

    def denom_LM(e):
        return e.denom_terms()[0][0]

    def as_expr(e):
        from sympy.polys import Poly
        np = Poly.new(e.data.numer(), *e.ring.generators)
        dp = Poly.new(e.data.denom(), *e.ring.generators)
        return np.as_expr() / dp.as_expr()

class GeneralizedPolynomialRing(Ring):
    r"""
    A generalized polynomial ring.

    A generalized polynomial ring is defined by a ground field `K`, a set
    of generators (typically `x_1, \dots, x_n`) and a monomial order `<`.
    The monomial order can be global, local or mixed. In any case it induces
    a total ordering on the monomials, and there exists for every (non-zero)
    polynomial `f \n K[x_1, \dots, x_n]` a well-defined "leading monomial"
    `LM(f) = LM(f, >)`. One can then define a multiplicative subset
    `S = S_> = \{f \in K[x_1, \dots, x_n] | LM(f) = 1\}`. The generalized
    polynomial ring corresponding to the monomial order is
    `R = S^{-1}K[x_1, \dots, x_n]`.

    If `>` is a so-called global order, that is `1` is the smallest monomial,
    then we just have `S = K` and `R = K[x_1, \dots, x_n]`.

    A few examples may make this clearer.

    >>> from sympy.abc import x, y
    >>> from sympy.agca.rings import GeneralizedPolynomialRing
    >>> from sympy import QQ

    Our first ring uses global lexicographic order.
    >>> R1 = GeneralizedPolynomialRing(QQ, [x, y], order=(("lex", x, y),))

    The second ring uses local lexicographic order:
    >>> R2 = GeneralizedPolynomialRing(QQ, [x, y], order=(("ilex", x, y),))

    The third and fourth rings use a mixed orders:
    >>> o1 = (("ilex", x), ("lex", y))
    >>> o2 = (("lex", x), ("ilex", y))
    >>> R3 = GeneralizedPolynomialRing(QQ, [x, y], order=o1)
    >>> R4 = GeneralizedPolynomialRing(QQ, [x, y], order=o2)

    We will investigate what elements of `K(x, y)` are contained in the various
    rings.

    >>> L = [x, 1/x, y/(1 + x), 1/(1 + y), 1/(1 + x*y)]
    >>> test = lambda R: [R.contains(f) for f in L]

    The first ring is just `K[x, y]`:
    >>> test(R1)
    [True, False, False, False, False]

    The second ring is R1 localised at the maximal ideal (x, y):
    >>> test(R2)
    [True, False, True, True, True]

    The third ring is R1 localised at the prime ideal (x):
    >>> test(R3)
    [True, False, True, False, True]

    Finally the fourth ring is R1 localised at `S = K[x, y] \ yK[y]`:
    >>> test(R4)
    [True, False, False, True, False]

    """

    def __new__(cls, K, gens, order=None, name=None):
        """
        Create a new generalized polynomial ring.

        Ground field is ``K`` and generators ``gens``. Order defaults to grevlex
        on all generators. If the argument passed is not callable, it is passed to
        build_order first.
        """
        from sympy.polys.monomialtools import build_order, grevlex
        if order is None:
            order = grevlex
        if not hasattr(order, '__call__'):
            order = build_order(order, gens)
        return Basic.__new__(cls, name, K, tuple(gens), order)

    @property
    def name(self):
        return self.args[0]

    @property
    def ground_field(self):
        return self.args[1]

    @property
    def generators(self):
        return self.args[2]

    @property
    def monomial_order(self):
        return self.args[3]

    def convert(self, expr):
        from sympy.core import sympify
        from sympy.polys import Poly
        from sympy.polys.polyclasses import DMF
        if isinstance(expr, PolynomialRingElement) and expr.ring == self:
            return expr
        if not isinstance(expr, RingElement):
            # convert from sympy expression
            numer, denom = sympify(expr).as_numer_denom()
            # XXX use ``poly`` instead?
            numerpoly = Poly(numer, gens=self.generators, domain=self.ground_field)
            denompoly = Poly(denom, gens=self.generators, domain=self.ground_field)
            # TODO should we use DMP when possible?
            res = PolynomialRingElement(
                    self, DMF((numerpoly.rep.rep, denompoly.rep.rep),
                    self.ground_field))

            # now validate that the denominator is indeed a unit
            if res.denom_LM() != (0,) * len(self.generators):
                raise ExactQuotientFailed(numerpoly, denompoly, self)
            return res
        raise CoercionFailed # TODO
